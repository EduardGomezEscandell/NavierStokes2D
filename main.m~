clear all;clc;

% Domain
width = 2;
height = 1;
duration = 5;

% Discretization
x_elems = 4;
y_elems = 4;
n_steps = 50;

degree = 1; %(space)

% Non-linearity
maxIter = 50;
tol = 1e-5;

% Physical properties
visc0 = 1;
mu = 1;

% Generating mesh
[coords,connect] = square_mesh(width, height, x_elems, y_elems, degree);
refelem = set_reference_element(degree);

n_nodes = length(coords);
n_elems = length(connect);
nodes_per_elem = size(connect,1);

% Selecting boundary conditions
removed_dof = [];
enforced_vals = [];
for n = 1:n_nodes
    X = coords(:,n);
    if X(1) == 0 % Gamma 1 and 2
        removed_dof(end+1) = n;
        enforced_vals(end+1,:) = 0 * ones(1,n_steps);
        removed_dof(end+1) = n + 2*n_nodes;
        enforced_vals(end+1) = 1;
    end
    if X(2) == 0 % Gamma 1 and 2
        removed_dof(end+1) = n + 2*n_nodes;
        enforced_vals(end+1) = 0;
    end
end

free_dof = 1:n_nodes;
free_dof(removed_dof) = [];

% Solution vectors
X_history = zeros(n_nodes*3, n_steps);
X = X_history(:,1);

% First iteeration
source = zeros(n_nodes,1);

% Initializing
dt = duration / n_steps;

% Assembling

for step = 2:n_steps
    
    X(removed_dof) = enforced_vals(:,step);
    
    K_global = sparse(n_nodes*3, n_nodes*3); % ux, uy, p, r
    F_global = sparse(n_nodes*3,1);
    
    modU = sqrt(X(1:n_nodes).^2 + X(n_nodes+1:n_nodes*2).^2);
    source = 1./(1 + exp(-10*(modU - 0.5)));
    rho = X(2*n_nodes+1:3*n_nodes);
    visc = visc0 + visc0 ./ (1 + exp(-10*(rho - 0.5)));
        
    % Obtaining arrays and matrices that need not iteration
    for el=1:n_elems
        nodes = connect(:,el);
        local_coordinates = coords(:, nodes);
        
        x =  [X(nodes), X(nodes+n_nodes), X(nodes+2*nodes)];
        v = visc(nodes);
        
        [K, K1, C1, M] = non_iterated_arrays(local_coordinates, x, v, refelem);
        
        z = zeros(size(K1));
        b(1:nodes_per_elem,1)   = K1 * x(:,1);
        b(nodes_per_elem+1:nodes_per_elem*2,1) = K1 * x(:,2);
        d = -(C1 + mu*K)*x(:,3) + 0.5 * M*source(nodes);
        
        F_local = [b; d];
        
        nodes = [nodes; nodes+n_nodes; nodes+2*n_nodes];
        
        F_global(nodes) = F_global(nodes) + F_local;
    end
        
    for iter=1:maxIter
        
        modU = sqrt(X(1:n_nodes).^2 + X(n_nodes+1:n_nodes*2).^2);
        source = 1./(1 + exp(-10*(modU - 0.5)));
        rho = X(2*n_nodes+1:3*n_nodes);
        visc = visc0 + visc0 ./ (1 + exp(-10*(rho - 0.5)));
        
        for el=1:n_elems
            nodes = connect(:,el);
            local_coordinates = coords(:, nodes);
            
            x =  [X(nodes), X(nodes+n_nodes), X(nodes+2*nodes)];
            s = source(nodes,:);
            v = visc(nodes,:);
            
            [K, K1, K21, K22, C1, C21, C22, M] = FEM_matrices(local_coordinates,refelem, x, v);
            
            % Assembly of Solvent
            % A*u = 0
            a = dt*M + 0.5*K1;
            z = zeros(size(K1));
            A =  [a z
                  z a];

            % Assembly of solute
            % B*u = S
            B = (dt*M + 0.5*C1 + mu*K);
            d = 0.5 * M * s;
            
            % Joining two systems
            % K*u = F
            K_local = [                                     A, zeros(2*nodes_per_elem,nodes_per_elem);
                       zeros(nodes_per_elem,2*nodes_per_elem),                                      B];
                   
            F_local = [zeros(2*nodes_per_elem,1); d];
                      
            % Assembling
            nodes = [nodes;
                     nodes + n_nodes;
                     nodes + n_nodes*2];

            K_global(nodes, nodes) = K_global(nodes, nodes) + K_local;
            F_global(nodes) = F_global(nodes) + F_local; 
        end
        
        % Newton-Rhapson
        R = K_global*X - F_global;
        R(removed_dof) = [];
        
        % Calculating jacobian
        J = calc_jacobian(coords, connect, X, visc0, mu, dt, refelem);
        J(removed_dof, removed_dof) = [];
        
        % Newton Rhapson
        X_new(free_dof) = X(free_dof) - J \ R;
        
        % Convergence condition
        error = norm(R);
        if error < tol
            break;
        end
        X = X_new;
    end
    
    if iter==maxIter
        warning('Maximum number of iterations reached before convergence');
    end
    
    Error(step) = error;
    
    if(mod(step - 1,10) == 0)
        fprintf('Step %3d of %3d completed\n',step, n_steps);
    end
    
    S_prev = S;
    X_history(:,step) = X_new;
end

post_porcessing(coords, X_history, duration)